Граф
====

Тук под граф ще имаме предвид краен неориентиран безтегловен граф.

Файловете [graph.h](graph.h) и [graph.cpp](graph.cpp) съдържат
имплементацията на структурата от данни граф чрез списъци на съседство,
която ще използваме за решаване на задачи. Основните операции върху граф са:
* `vertices()` – достъп до върховете на графа
* `successors(v)` – достъп до съседите на връх `v`
* `add_vertex(v)` – добавяне на връх `v` в графа
* `add_edge(u, v)` – добавяне на ребро между върховете `u` и `v`
* `is_edge(u, v)` – проверка дали има ребро между върховете `u` и `v`

Обхождане в дълбочина
---------------------
Напишете функция `void dfs(Graph& graph)`, която обхожда даден граф `graph`
в дълбочина ([DFS](https://en.wikipedia.org/wiki/Depth-first_search)).

[Решение](dfs.cpp)

Обхождане в широчина
--------------------
Напишете функция `void bfs(Graph& graph)`, която обхожда даден граф `graph`
в широчина ([BFS](https://en.wikipedia.org/wiki/Breadth-first_search)).

[Решение](bfs.cpp)

Път между два върха
-------------------
Напишете функция `list<int> path(Graph& graph, int start, int end)`,
която по даден граф `graph` и върхове `start` и `end` връща пътя от `start`
до `end`.

[Решение](path.cpp)

Най-къси пътища от даден връх
-----------------------------
Напишете функция `map<int, int> shortest_paths_from(Graph& graph, int start)`,
която по даден граф `graph` и връх `start` връща `map<int, int>`, който на
всеки връх `v` съпоставя дължината на най-късия път от `start` до `v`.

[Решение](shortest-paths.cpp)
